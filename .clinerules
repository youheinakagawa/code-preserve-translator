# Code Preserve Translator プロジェクトルール

## プロジェクト固有のパターン

### 命名規則
- **ファイル名**: キャメルケース (例: `contentScript.ts`, `translationEngine.ts`)
- **クラス名**: パスカルケース (例: `TranslationEngine`, `CodeBlockDetector`)
- **関数名**: キャメルケース (例: `translateText()`, `detectCodeBlocks()`)
- **変数名**: キャメルケース (例: `apiKey`, `cacheTimeout`)
- **定数**: 大文字のスネークケース (例: `API_ENDPOINT`, `DEFAULT_TIMEOUT`)
- **コンポーネント**: パスカルケース (例: `SettingsPanel`, `ChatInterface`)

### コード構造
- 各機能は独自のモジュールに分離する
- 関連する機能は同じディレクトリにグループ化する
- ユーティリティ関数は共通のユーティリティモジュールに配置する
- インターフェースと型定義は専用の型定義ファイルに配置する

### コーディングスタイル
- TypeScriptの厳格モードを使用する (`"strict": true`)
- 明示的な型定義を優先する
- 非同期操作にはPromiseとasync/awaitを使用する
- コメントは日本語で記述する（国際化対応のためのコメントは英語も可）

## ユーザー好み

### 開発環境
- VSCodeをプライマリエディタとして使用
- ESLintとPrettierを使用してコードスタイルを強制
- Chromeの開発者ツールを使用してデバッグ

### ワークフロー
- 機能ごとに個別のブランチを作成
- コミットメッセージは日本語で、変更内容を明確に記述
- プルリクエストはレビュー後にマージ

### テスト戦略
- Jestを使用してユニットテストを実施
- 重要なコンポーネントには高いテストカバレッジを確保
- E2Eテストには手動テストと自動テストを組み合わせる

## 既知の課題と対応策

### 技術的課題
1. **コードブロック検出の精度**
   - 様々なウェブサイトでのコードブロックの正確な識別が難しい
   - 対応策: 一般的なコードブロックのパターンを特定し、ヒューリスティックアプローチを採用

2. **APIコストの最適化**
   - OpenAI APIの使用コストを最小限に抑える必要がある
   - 対応策: 効率的なキャッシュ戦略と最適化されたプロンプト設計

3. **ストレージ制限**
   - Chrome拡張機能のローカルストレージには容量制限がある
   - 対応策: 効率的なデータ構造と古いデータの自動クリーンアップ

### UX課題
1. **翻訳の遅延**
   - API呼び出しによる翻訳の遅延がユーザー体験に影響する可能性がある
   - 対応策: バックグラウンド処理、プログレスインジケーター、キャッシュの活用

2. **設定の複雑さ**
   - 多くの設定オプションがユーザーを混乱させる可能性がある
   - 対応策: 直感的なUIデザインとデフォルト値の適切な設定

## 進化するプロジェクト決定

### アーキテクチャの決定
- モジュール化されたアプローチを採用
- コンテンツスクリプトとバックグラウンドスクリプトの明確な責任分担
- メッセージパッシングを使用したコンポーネント間通信

### 技術選択
- TypeScriptを使用して型安全性を確保
- Webpackを使用してモジュールをバンドル
- Jestを使用してユニットテストを実施

### 翻訳戦略
- OpenAI GPT-4を使用して高品質な翻訳を実現
- コードブロックを検出するためのヒューリスティックアプローチ
- 効率的なプロンプト設計によるAPI使用の最適化

## ルール追加

1. **コマンドの実行ルール**
   - コマンドは`&&`や`;`などで同時に連続して実行しないこと。

2. **Gitの使用ルール**
   - `git add .`は禁止。
   - コミットしようとする意味の単位で行い、不要なファイルをコミットしないようにすること。
